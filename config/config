# vim: ft=python

Import('env')

# The components dictionary contains the dependency information for each
# component. In the future we may want to have each component specify for
# itself rather than doing it all in one place.
components = {
        "boxer": [],
        "consoler": [],
        "filler": [],
        "fonter": ["freetype2", "fontconfig"],
        "green": [],
        "pdfer": ["poppler-cpp", "freetype2", "fontconfig"],
        "pnger": ["libpng"],
        "sdlcsr": ["sdl"],
        "termer": ["freetype2", "fontconfig"]
        }

# The requirements dictionary holds information about all the possible
# required external packages.
# key: pkg-config name for package
# value: (lib, header, lang)
#    arguments to pass to CheckLibWithHeader function.
requirements = {
        "libpng": ('libpng', 'png.h', 'c'),
        "poppler-cpp": ('poppler-cpp', 'poppler-document.h', 'c++'),
        "freetype2": ('freetype', 'ft2build.h', 'c'),
        "fontconfig": ('fontconfig', 'fontconfig/fontconfig.h', 'c'),
        "sdl": ('SDL', 'SDL/SDL.h', 'c')
        }

# Read the user specified configuration
SConscript('local')

output = ["Configuration Summary"]

# Use pkg-config to extend LIBS, LIBPATH, and CPPPATH lists
print "Using pkg-config to find info about required packages..."
for req in requirements.keys():
    try:
        env.ParseConfig("pkg-config --silence-errors --cflags --libs %s" % req)
    except OSError:
        pass

# Run tests to see which requirements are actually met
output.append("Requirements:")
satisfied = []
conf = Configure(env, conf_dir='.', log_file='config.log')
for req in requirements.keys():
    reqprint = req
    while len(reqprint) < 16:
        reqprint += " "

    (lib, header, lang) = requirements[req]
    if conf.CheckLibWithHeader(lib, header, lang):
        satisfied.append(req)
        output.append("\t%s yes" % reqprint)
    else:
        output.append("\t%s no" % reqprint)

# Based on the requirements which were met, determine which components should
# be built.
# Note: filler must come before green in this list, which is why we sort it.
output.append("\nComponents:")
tobuild = components.keys()
tobuild.sort()
for comp in components.keys():
    for req in components[comp]:
        if not (req in satisfied):
            tobuild.remove(comp)
            break

for comp in components.keys():
    compprint = comp
    while len(compprint) < 16:
        compprint += " "

    if comp in tobuild:
        output.append("\t%s yes" % compprint)
    else:
        output.append("\t%s no" % compprint)
        missing = "\t\t requires:"
        for req in components[comp]:
            if not (req in satisfied):
                missing += " %s" % req
        output.append(missing)

# Print the summary
print "\n".join(output)

# And save it to a file.
env.Default(env.Textfile(target='summary', source=output))

Return("tobuild")

