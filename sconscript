
import os.path
import re

env = Environment(
        tools=['ar', 'asciidoc', 'gcc', 'g++', 'link', 'textfile'],
        toolpath=['scons'],
        CPPPATH=[],
        LIBPATH=[],
        LIBS=[]
        )

Export('env')

env['CFLAGS'] = ['-ggdb', '-Werror']

# define the version string.
env['VERSION'] = "1.2.0"
env.MergeFlags("-DFOCUS_VERSION_STRING=\\\\\\\"%s\\\\\\\"" % env['VERSION'])

# configuration
if not os.path.exists('../config'):
    print "Error: 'config' file not found."
    env.Exit(1)
SConscript('config')


# Use pkg-config to extend LIBS, LIBPATH, and CPPPATH lists
for req in ['libpng', 'poppler-cpp', 'freetype2', 'fontconfig', 'sdl']:
    try:
        env.ParseConfig("pkg-config --silence-errors --cflags --libs %s" % req)
    except OSError:
        pass


# PROGRAMDOC 
# Generates documentation for a program component.
#  name - the name of the component, for example "filler"
# Assumptions:
#   $name.txt is the asciidoc description of the program.
#   $name.1.txt is the asciidoc man page for the program.
def programdoc(name):
    mantxt = name + ".1.txt"
    man = name + ".1"
    env.Man(man, mantxt, ASCIIDOCFLAGS="-a 'VERSION=$VERSION'")
    env.Default(man)
    env.Install("$PREFIX/share/man/man1", man)

env['PROGRAMDOC'] = programdoc

# LIBRARYDOC
# Generates documentation for a library component.
#  name - the name of the component, for example "fonter".
# Assumptions:
#   $name.h is a header file where each function to be documented is proceeded
#   with a special comment of the form:
#   /// name - brief
#   ///
#   /// asciidoc description
#   /// more description
#   /// etc...
#   prototype;
#
#   The prototype may span multiple lines. The current implementation is very
#   picky about everything else, so be exact or the function will be ignored.
# Generates: man pages for each function, and an asciidoc file with the
# description suitable for including in a guide called $name.txt.
func_re = re.compile(r"/// ([a-zA-Z_0-9]+) - (.*)((?:\n///.*)*)\n([^;]*);")
titlebar = "=============================================================="
def librarydoc(name):
    header = File(name + ".h").srcnode().abspath
    entries = func_re.findall(open(header, "r").read())
    for f in entries:
        name = f[0]
        dict = {
                "@NAME@": name,
                "@TITLEBAR@": titlebar[:len(name)],
                "@BRIEF@": f[1],
                "@DESCRIPTION@": f[2].replace("\n/// ", "\n").replace("\n///", "\n"),
                "@PROTOTYPE@": f[3],
                "@VERSION@": env['VERSION'],
                }
        env.Substfile(name + ".3.txt", '#/src/function.3.txt.in', SUBST_DICT = dict)
        env.Substfile(name + ".txt", '#/src/function.txt.in', SUBST_DICT = dict)
        man = env.Man(name + ".3", name + ".3.txt")
        env.Default(man)
        env.Install("$PREFIX/share/man/man3", man)

env['LIBRARYDOC'] = librarydoc

components = [
        'boxer',
        'consoler',
        'filler',
        'fonter',
        'green',
        'pdfer',
        'imager',
        'sdlcsr',
        'termer'
        ]

# Build each of the components
for comp in components:
    env['RELEASE'] = Dir('focus-%s/src/%s' % (env['VERSION'], comp))
    SConscript('src/%s/sconscript' % comp)

# Build the documentation
env['RELEASE'] = Dir('focus-%s/src' % env['VERSION'])
SConscript('src/sconscript')

env.Alias('install', '$PREFIX')


env['RELEASE'] = Dir('#/release/focus-%s' % env['VERSION'])
env.Install("$RELEASE", ['COPYING', 'makefile', 'sconscript', 'sconstruct'])
env.Install("$RELEASE", "#/doc")
env.Install("$RELEASE", "#/src")
env.Install("$RELEASE/scons", "#/scons/asciidoc.py")
release = env.Command('%s.tar.gz' % env['RELEASE'], "$RELEASE",
        "tar -c -f $TARGET --directory ${TARGET.dir} focus-$VERSION")
env.Alias('release', release)

