
Mon Apr  4 17:11:18 EDT 2011

Task: Implement a terminal emulator using this framework.

I checked out freetype, and it looks like it has all need to draw characters
from a truetype (and many other) fonts, so I shouldn't need SDL to implement
the terminal.

It will be like fbterm, but I think this time around I should do things a
little differently. Rather than manipulating the displayed image for things
like character erasing and scrolling, I should keep in memory the characters
currently displayed to the screen, and draw those on demand.

Perhaps we can use a circular buffer to make scrolling easier.

Maybe this will help with performance. Maybe not. But one thing it certainly
does is separate the terminal control and content code from the graphics code.

The first big question is: what should I call the terminal?

Mon Apr  4 18:47:44 EDT 2011

I have a name proposal: termer
It's pretty lame, but simple.

For now I can include the source with the rest of the focus project.
(Let's say the focus project includes the consoler library and a number of
sample applications). Eventually there's no reason for it to be bundled with
the other consoler programs.

Cool. Let me take this opportunity to refactor what fbterm was if I can. What
should the design look like?

Components:

Input Keys -> Actions
    Where this is mostly just copy it to the client, but sometimes copy more
    complex stuff, such as for arrow keys, and handle CTRL and SHIFT modifiers
    and such.

    This is called vti in fbterm.

Output Chars -> Actions
    Interpret output from the client.
    This is often: draw a character and move the cursor.
    Sometimes it is interpreting sequences.

    This is called vto in fbterm.

Action -> ConsoleState
    We keep console state: what characters are on the screen, their colors,
    current color, cursor position.

    This is affected by commands from the Output Chars.

    This is called sdlt in fbterm.

    But in fbterm it dealt with both display and console state. The state
    (characters at least) was stored as part of the raster image of the
    screen.

    Here I imagine we'll just use a 2D array (maybe circular buffer) to hold
    all the character contents (and their characteristics: color, style, etc).

    The actions will update those appropriatly. There need not be any notion
    of how to draw the characters on the screen. So in theory if I wanted to
    this same module could be reused by fbterm and termer.

ConsoleState -> Display
    Some way to draw a display. Perhaps we provide callback functions to
    ConsoleState module to call when display is performed? Hmm...
    
All that remains in fbterm is this configuration module (which uses tcl), and
the main program which glues things together.

I don't know what the best way to do this is. But maybe I can think of it in a
hardwarish kind of way. Let's say the inputer takes a stream of key presses
as inputs and outputs a stream of Actions (which are maybe just character
strings?) to send to the client.

Then say the output takes a stream of key presses and converts it to a stream
of actions.

Then say the ConsoleState takes a stream of input actions and ... has some way
to query it's state. Maybe someway to ask what's changed since the last query?
That might be nice.

Then say the displayer has a pointer to the console state, whenever asked it
can update the display. Perhaps one of the input actions can be "IDLE"?

And these all can communicate through FIFOs? That seems a little strange to
me, I must admit. Ug. I'll keep thinking about it.

I wonder if I can think about it in terms of a transaction based shared memory
model like in fiddler?

Sat Apr  9 12:17:45 EDT 2011

Let me start one piece at a time.  Starting with the input module.

Input is: a sequence of key presses and key releases. Because I guess I'll
handle key modifiers manually too (is shift down? etc...).

Output is: well, eventually a sequence of bytes sent to the terminal
application. So maybe we can think of it as just a file.

From the modules point of view it should, I think, be running in its own
thread. It should explicitly perform gets to get an input, and it should
explicitly perform puts to output an output.

So maybe we instantiate it with callback functions: get and put. The get
function will return the next key press or release (so, event). The put
function will take a string of bytes, perhaps with explicit length.

Sat Apr 30 09:51:40 EDT 2011

I've thought about things, and decided yes, even though it will get painful, I
should implement the terminal emulator in haskell. Understand what the pain
is. Because I understand the pain of C, and I know haskell fixes much of that
pain. I don't understand the pain of haskell. Maybe if I did I could figure
out how to fix it.

In haskell things look like this:
- inputter:  process which gets events, puts characters
- outputter: process which gets (UTF8) characters, updates shared character
  array.
- displayer: process which draws shared character array to the screen
  Ideally this gets lower priority than the outputter. Is that possible?

And is that it? Those are the only processes I need? Maybe a main program to
set things going, and certainly libraries to access the underlying consoler
protocol, but that seems fairly nice to me.

First step is inputter. I should be able to implement and test it purely.

Steps to implement
 + define event type
 - implement inputter module
 - test inputter module

Easy, no? Let me dive into a rough draft.

Sat Apr 30 09:58:44 EDT 2011

I defined the event type. That was trivial.
Now for the inputter module.

Oh my god. The inputter doesn't even have to know about STM haskell! It can be
made to work with a general monad, which should make testing it trivial!
Wonderful!

Except, I need to have some way of stopping the inputter. Perhaps it can
listen for a Quit event of some sort? That would make testing much easier. It
could be useful temporarally.

Sat Apr 30 11:37:10 EDT 2011

I've written the rough draft of the inputter. It's a little verbose, but not
terrible. I fear for performance (that we do hundreds of comparisons when we
could just do a single addition to translate keysym to input char), but I'm
putting that out of my mind until it is really shown to be a problem.

Now what I need is to write some tests.
I guess I can start with a really simple test: verify KEYSYM_A sends 'a'.
I can add more tests if I want to, or just one, then add more when things fail
to work. Whatever. Minimum is one test though. Set up the hunit stuff, get it
all to compile.

Sat Apr 30 12:34:03 EDT 2011

My three tests pass! First try. Nifty.

So, what's next?

Next is the outputter module.
The task of the outputter module is to interpret a stream of characters into
actions which modify the terminal state. Basically actions are:
change the cursor, change characters and attributes of the character buffer.

So, before doing the translation, I really want an abstract data type
representing the console state.

It should include the following:

- Number of lines
- Number of columns
- The current cursor position (line and column)
- The current fgcolor, bgcolor, style
- For each position: character, style, fgcolor, bgcolor
    color is one of: black, red, green, yellow, blue, magenta, cyan, white
    style is one of: reverse, bold

Methods on the terminal might be:
 - clear
 - insert line
 - clear to end of line
 - scroll forward
 - set foreground
 - set background
 - set reverse
 - set bold

Do you think? What about
 - cursorup, cursordown, etc...
 - some way to get at the contents of cells.
    So I think the CELLS should be public, but representation of the terminal
    (be it array, tree, list, whatever) should be private.

Cool. That's fairly clear. Or rather, the direction is clear, the detail has
to be worked out. Shall I do that on the fly?

Sure, why not? But what do I call this module? Terminal? Display? Screen?
Output?

You know? I like Screen. We can save Display for displaying the screen. Here I
go then. Wish me luck.

Sat Apr 30 14:54:35 EDT 2011

I completed a rough draft of Screen. I think it has everything we'll need for
fbterm equivalent functionality. The details are not at all documented (or
decided on) yet, which I should probably do...

I would say the next step is to write some tests for the Screen module. But
before I test a function, take the time to work out the specific details for
that function which makes sense to have and document it.

Cool. Sounds like a plan.

Sun May  1 11:31:26 EDT 2011

I've gone through the terminfo capabilities. I think it would be great of the
screen functions were named after these capabilities. That way it's clear
based on terminfo documentation what the thing should do, and I don't have to
come up with my own names.

Cool. So then, initial capabilities I should do are:

+ carriage_return
+ column_address
+ cursor_address
+ cursor_down
+ cursor_home
+ cursor_left
+ cursor_right
+ cursor_to_ll
+ cursor_up
+ parm_left_cursor
+ parm_right_cursor
+ parm_up_cursor
+ parm_down_cursor
+ row_address
+ newline
+ tab

+ clear_screen
+ clr_bol
+ clr_eol
+ clr_eos

+ enter_bold_mode
+ enter_reverse_mode
+ exit_attribute_mode

+ set_background
+ set_foreground

+ delete_character
+ parm_dch
+ delete_line
+ parm_delete_line
+ erase_chars

+ insert_character
+ parm_ich
+ insert_line
+ parm_insert_line

+ scroll_forward
+ parm_index
+ scroll_reverse
+ parm_rindex

For the fun of things, maybe I can say I'll implement all of these as Screen
functions, test them all, then I'll be in great shape to go on to implement
the rest of the terminal emulator.

Cool. Am I ready?
Allow me to spend 20 minutes on this, see how far I get.

Sun May  1 13:34:20 EDT 2011

So I took a bit more than 20 minutes to do this. Fine. But now I have all the
big ones implemented. I suspect almost all of them have bugs in them, so I
should get a nice test suite going. That's the plan now. I'll write tests for
each function, try to get them all working. Can I do it in 25 minutes you
think? We'll see.

Sun May  1 15:20:01 EDT 2011

So I write some tests. Mostly for the cursor motions. The reason I don't feel
like writing more right now is it is hard to write tests that check multiple
cells on the screen in the same test. So I'll wait until I actually run into
bugs, or get bored enough to write the tests, before writing more tests.

That said, what's the next step? Assuming inputter works swell, and assuming
screen works well, the next step should be outputter, right?

The job of outputter is to convert a sequence of characters from the client
into a sequence of Screen commands. It would be awesome if I could test this
without Screen, don't you think?

Or maybe I need to come up with a good way of describing a screen for test
purposes. Then I could give a long string, do the conversion and update the
screen, then test the final screen is correct.

I suppose I could send a string, generate an output screen.
And then on a different screen send all the expected commands.
Then compare to see whether the resulting screens are the same.

That's not so bad an idea.

What's the outputter interface? It should be its own process. It gets two
functions I think:
  getf :: m Char, get the next input character
  update :: Screen -> Screen -> m (),
    Make a change to the screen.

  For testing, the update function looks a lot like modify on a State Screen
  monad.

Good, I like this idea for testing the outputter.

I don't really feel like working on the output just at this moment (must be
time to take a walk or something). Let's imagine I've already implemented
outputter. Then what would be the next step? After outputter is displayer.
That's where things will get tricky, because I'll want to incorporate the CNSL
stuff into haskell, and freetype library. Basically the display turns a Screen
into a CNSL buffer. After that things get tricky again, because I have to
start worrying about concurrency, getting and setting CNSL events and
displays, launching the client and so on.

So it only gets harder, and much harder. Or rather, much more annoying.

Tue May  3 09:20:10 EDT 2011

Outputter! I could try using parsec, but I feel like that is overkill for this
simple parsing. Basically all we need to parse are character literals and
integers. So if I can have a function to extract the next character literal
(which will be called getf, we already have it), and a function to extract the
next integer, we should be in good shape.

I'll probably want to buffer a single character.

And I'll need to decide on the terminfo. Perhaps it would be better to write
the terminfo file first, so I know what all sequences I need to parse. Yes,
that would make sense. I want to stay ansi or vt102 or common compatable
rather than make up something wildly different.

So let me do that now, I think I can do that.

Tue May  3 09:52:36 EDT 2011

I did that. What do we see? It's as I expected, we only need to parse literal
characters and decimal integers.

Rather than require a buffer, I suggest we have the following functions:
 getf :: m Char     - get the next character literal
 getnum :: Char -> m (Maybe Integer, Char)
        - read the integer at the front of the string and the following char.
          If there is no integer at the front of the string, return Nothing
          for that field.

 In fact, I could use the getnum function always if I wanted to...

Yes, that looks like it will be a straight-forward, relatively painless way of
parsing the control sequences.

Fri May  6 21:30:06 EDT 2011


I figured out how to use freetype to draw characters on the screen. For the
most part anyway. It's not too bad.

Now that outputter is up and running, we've reached the hard part: hooking up
CNSL to haskell.

Tasks involved:
 - haskell function to get next input event
 - haskell function to fork a terminal client
 - haskell function to write a character to the terminal client
 - haskell function to read a character from the terminal client
 - haskell function to draw a character with given color

And generally just understanding how all this will work. That is, defining the
interface.

Options:
 - keep as much CNSL stuff on the C side as possible
   - so only get CNSL_Events, and draw characters. Drawn characters can be
     immediately updated and displayed, or have a function to send display,
     where the display is implicit. When drawing characters we can specify
     location in terms of row and col rather than in pixels.

 - try to make haskell interface for CNSL completely general
  - have a way to allocate a buffer.
  - have a way to render a character to a buffer at the given location.
  - have a way to send that buffer to the server. etc...
    
That's something I'll have to think about for the next step.

Sat May  7 18:02:23 EDT 2011

Here's the plan next. I have this interface between haskell and C to implement
which looks something like:

init - initialize stuff. Maybe even takes the terminal client application and forks it.
getevent - get the next event
    I may want to split this up into: next, type, and value methods to make the conversion easier.
putchar - pass a character to the terminal client.
    Or would it be easier to just return a write file handle? Perhaps.
getchar - get a character from the terminal client
    Would probably be easier to return a read file handle (from init) and use that.
drawchar - draw a character (using freetype) on the display (implicit).
    input is: character, foreground color, background color, row, col
upddisplay - send the display (with characters drawn on it) to the console server.

Implement the C and haskell sides of the interface. That's the next step.

After that, just write some haskell to use the interface. Basically it's: initialize, then fork threads (don't even need SMT, just CC will be enough) to do
    inputter: get is getevent, put is putchar
    outputter: get is getchar, updatef is update screen, drawchars and update display
    
And it should be that simple. Cool. I'll work that tomorrow.

Sun May  8 10:40:17 EDT 2011

Working out the haskell/C interface is more detail now.

First, some questions to answer:
 - Is is possible to send structure across haskell FFI? How?
    If so, we should just have a getevent function, if not we should have
    next, type, and value methods for sending an event from C to haskell.

    It looks like it is possible using Storable, but it also looks like it's a
    pain. Much easier for now to just make multiple function calls to get the
    data.

 - Is is possible to send enums across haskell FFI? How?
    If so, that would be useful in sending color info from haskell to C
    Otherwise just pack it to an int.

    Doesn't look like it. Just convert to an Int and unconvert.

 - Is there a way to do an fdopen in haskell?
     If yse, then putchar and getchar can be replaced with files, and we should
     automatically get character support.

     It looks like it's possibly possible, if I hack into some ghc specific low
     level stuff, but probably unpleasent.

 - How is unicode character translation done across haskell FFI?
     It would be nice. For putchar and getchar if I need those, and for
     drawchar to specify the character.

    There is a way to send strings, which seems to handle unicode. There are
    also functions to convert Char to CChar which just drop unicode characters.


So, the conclusion? It's pretty sad. I'm going to loose unicode I suspect. I'll
have to fix that later. It should be okay for the first version of term.

So the interface is as before. I'll want a prefix. Maybe CTERM? Sure... For
the C side of Termer.

int CTERM_Init()
  Initialize the cterm. It does
    - initialize CNSL,
    - initialize freetype
    - fork a client process: for now always just fork /bin/bash or some such.
    - allocate a CNSL_Display

void CTERM_EventGet()
    - Get the next event. Stores the event in a static place accessible with  
      CTERM_EventType and CTERM_EventValue

CInt CTERM_EventType()
    - Return the type of the most recently gotten event.
      Do not call before EventGet is called, as you'll get undefined results.

CInt CTERM_EventValue()
    - Return the value of the most recently gotten event.

void CTERM_ToTermClient(CChar c)
    - Send the character c to the terminal client.

CChar CTERM_FromTermClient()
    - Get a character from the terminal client.

void CTERM_DrawCell(CChar c, CInt style, CInt fgcolor, CInt bgcolor, CInt col, CInt row);
    c - the character of the cell
    style - bold or not
    fgcolor - foreground color enum
    bgcolor - background color enum
    col - column of cell to draw
    row - row of cell to draw

    Draw a cell using freetype to the right place in the display.

void CTERM_ShowDisplay()
    Send the current display to the consol server.


I think this will be a good first start. And I have clear what I need to
write.  The task now is to implement the c cide of this, let's say in
ctermer.h and ctermer.c.

Sun May  8 13:21:25 EDT 2011

I wrote the rough draft of ctermer.h and ctermer.c. No issues. It seems rather
straight forward. Next step? I might as well get it compiling before I move on
to the haskell side of the interface. Should I make a library? Or just a .o
file? I'll have to look at other projects I've done with ffi.

It looks like I just pass the c file to GHCProgram, so I'll wait until I have
the haskell side up to try compiling.

Next steps:
1. The haskell side: CTermer.hs.
2. Use CTermer.

I expect this is actually a very little amount of code, which shouldn't take
an hour to write up and get compiling.

What are the problems I anticipate?
 - How do we know the dimensions of a character cell?
 - I don't have the font I use installed, so that's bad.
 - Maybe need to install concurrent haskell package?
 - There's bound to be deadlock when I run it, and it will likely crash my
   machine if I'm not running in X. So I should probably debug this in X
   (maybe go to the athena lab once it compiles on my netbook).
 - What does the end game look like? How do I stop the terminal emulator?

So, time for lunch, then I'll finish writing this sucker.

Sun May  8 14:24:54 EDT 2011

I wrote CTermer.hs. Now all that's left is the main application, right?
I think I can do this. Call it Termer.hs. Inputter and outputter is all I
need, yes?

Sun May  8 14:40:56 EDT 2011

There, rough draft is all written. In theory I can end the application by
typing Ctrl-E. Time to try compiling and seeing what all the problems are.

Sun May  8 14:59:55 EDT 2011

It compiles!
Now, obviously it won't work if I run it. I'll have to reboot my computer and
all. So let me commit and push now, then try to get it working on my netbook.
Once it crashes things, switch to an athena cluster, get everything up to
date, then try to get things working there.

Sun May  8 16:12:52 EDT 2011

This font thing is annoying. What's the right way to specify the font to use?

Anyway, after the font issue we run into this bug: y is out of range in our
call to SetPixel in DrawCell. The issue: CHAR_HEIGHT isn't right. How do I
make it right?

I made that bigger and guess what! It sort of works! Very slowly, fine, but I
see characters going by, but then they overwrite eachother and I see lots of
funny squares and all that.

So, let's see how I can make progress...

It says: execl: no such file or directory I think.
Ah yes, I had a typo. Trying again...

Problem now: unhandled control sequence: ESC[1;
So switching to sh...

Problem now: I only see the top half of the first row. Why is that (do we
ignore row?). And return outputs some square on the display instead of going
to the next line.

If I keep typing, it eventually wraps around. The characters are not being
drawn in their entirety, and they certainly aren't being drawn in a consistent
part of the cell.

So I think the next steps are:
 - really understand how I can know the cell character dimensions based on the
   font size, and where in the bitmap the characters are getting drawn.
 - I think we have the following bug which should be easy to test: when you
   reach the end of the last line, it should automatically scroll the
   terminal.
 - We don't end properly: I think application outputs a bunch of EOF
   characters or NULs. I should use that as trigger for when to quit.

I would much prefer to get the font stuff working first so I can see better
what's going on. That's the key next step.

But I must say, this is really cool. It's going to work!

Okay, let's figure out the font thing.

Current thoughts:

We specify pixel size width and height. It looks terrible unless I set width
and height as the same: like 32x32, but I know the cell sizes shouldn't be
square.

My belief is freetype produces a bitmap which only contains lines and columns
with pixels in them. That is, it won't include black space around the edge. To
make up for that, it tells you where the bitmap should be placed with respect
to some known point on the character using bitmap_left and bitmap_top.
Specifically, bitmap_left is the number of pixels to the right of the origin
of the CELL where the bitmaps first column should be placed. And bitmap_top is
the number of pixels number of pixels above the CELL where the bitmaps top row
should be placed?

What I would like to know is: from freetype, what is the bounding box for the
CELL? What are the dimensions?

Now to read some documentation.

Read about FT_Set_Pixel_Sizes

bitmap_left: horizontal distance from the current pen position to the leftmost
border of the glyph bitmap. If pen is cell, that sounds right.

bitmap_top: vertical distance from the pen position to the topmost border of
the glyph bitmap. Oh. That's a little different right? No. That's what I
thought too.

Aha! Here's an important point I may have missed. The y direction for display
buffer is 0 at the top, and increases going down.

So given I want to draw a character at cell (0, 0), whose x and y coordinates
are 0 and 0, I want to draw the bitmap's upper left corner at x = bitmap_left
and y = height - bitmap_top, right? Isn't that what I do?

Oh, here's something: slot->advance.x and slot->advance.y may contain the
width and height of the cell (but 64 times that really).

face->glyph->metrics.width: bounding box of a glyph
                    .height

These seem to be character specific. I'm more interested in characters in
general (but maybe that only makes sense for monospace?).

Read about FT_Set_Pixel_Sizes
Read about FT_Size_Metrics
Read about FT_Glyph_Get_CBox

Aha, making progress now...
Fields of the face:
    units_per_EM
    bbox - aha! This is good
    height

Even better:
    face->size->metrics.height

Oh, so Set_Pixel_Sizes just relates pixels to EM, where EM is like the font
metrics: 1000 for example.

I think I should do an experiment.
Print out the following things:

advance.x, advance.y, face->size->metrics.height
units_per_EM, bbox, height. Let's use a 32 bit pixel size.

Sun May  8 17:27:40 EDT 2011

Oh, I found  a bug. I was using w instead of h. Now characters are lined up, I
can see them all. Not sure about the size it's supposed to be from the
metrics, but it looks good.

Good enough, indeed to start making progress. Let me just figure out how to
exit it cleanly so I can work on it on my netbook. And I think I'm in shape
now to start making great progress!

Sun May  8 21:12:20 EDT 2011

Suspected bugs to test and fix:
 + Doesn't autoscroll at bottom of terminal.
 - backspace doesn't move the cursor backwards.
 + newline character (and enter) not treated as newline.
 + characters overstrike instead of replacing what's there.
 - linefeed (cursor_down) at bottom of terminal should scroll?
    Or maybe this is: terminfo should set number of lines correctly so the
    program knows not to cursor down off the bottom of the screen?
 - bottoms of low characters like p and g are getting cut off.

All of these should be pretty easy to test and fix, except the last is a
little tricker to test. Let's go one at a time.

Autoscroll: add as Screen test.

Sun May  8 21:47:12 EDT 2011

So, it's going good. Things are getting better. Still lots of bugs.

And very soon I'm going to find out performance is unbearable and I'll want to
work on that. There are certainly many things I can think of to improve
performance, I just have to figure out where the bottleneck is. I hope it's
not updating the whole screen (just like in pdfer), because that might be
harder to find a fix for (I suppose keep track of what's been changed and only
update the small part of the screen).

Cool. Very cool.

Mon May  9 18:24:36 EDT 2011

Let's talk about how we specify the font. I know what font I want. I know the
path to it. The trouble is, I kind of want it to be implicit.

Anyway, ideally we could specify the font as just: Bitstream Vera Sans Mono,
or even better Monospace. I should be able to do this if I make use of
fontconfig, which we'll want to use eventually anyway (it is the "right" thing
to do I feel like).

So let me learn about fontconfig and try to make it so I can specify my font
simply as Monospace. Then let fontconfig do all the work of finding the right
font file on the computer. And who knows, maybe fontconfig will also help me
to find glyphs for strange unicode characters.

I'm starting a task: fontconfig.tsk.

Tue May 10 08:54:27 EDT 2011

Bug review:

 - backspace doesn't move the cursor backwards.
 - enter at bottom of terminal does bad things.
 + bottoms of low characters like p and g are getting cut off.
   (termcharsize.tsk)
 + it's really really really really really slow.
   (termperf.tsk)
 - cursor isn't displayed

I think the main priorities should be performance and proper character
spacing. Let me open up new tasks for these, because otherwise I'll get way
too disorganized.

Wed May 11 20:38:45 EDT 2011

At this point what's keeping me from using termer for my terminal really is
the terrible performance. So that's the next focus I think. I'll make it the
right size terminal, see how slow it goes, then do what it says in
termperf.tsk to make it go faster. Probably I'll just experiment rather than
really figuring out what's going on, because figuring out how to profile stuff
will be lots of work.

Thu May 12 21:33:08 EDT 2011

More bug reports:
 + backspace doesn't move the cursor backwards.
 - enter at bottom of terminal does bad things.
 - cursor isn't displayed
 + ls --color causes bad sequence: 0m
    0m should be the same as turn off character attributes according to vt102
    manual. same as the control sequence m if I support that.
 + man says terminal not fully functional
    Problem was I hadn't installed my terminfo file on this computer.
 + man sends ESC [ m and we crash.
 + man sends ESC [ 22 m and we crash.
    This means set normal intensity, so turns off bold?
    I don't know how to specify this in terminfo.
 - man sends ESC [ 4 m and we crash.
    That's underscore. Um... what do I do if I don't support underscore?
    Perhaps I should support it.
    Why doesn't the man page have any underscore when I print it using fbterm?
    Maybe screen takes care of that?

 + screen sends ESC[0;(Just 10,'m')
    And then we die. But wait, isn't that in the terminfo? Yes, so I should
    support it.

 + vim sends ESC[24;(Just 1,'H')
    And then we die.

 + vim within screen sends ESC[(Just 23,'B')
    And then we die.
 
 - ls --color causes bad sequence: 1;
    1; means 1 is the first parameter, not sure what the next are. I should
    print that out too.   getting: ESC[1;34m
    What, exactly, does that mean?

    1 means turn on bold, 34m means set foreground blue.
    I guess I need to support this.
    I'll also need to suport 0;#m. Kind of annoying...
 
 - reverse video (I think) looks totally messed up


You know what? I think rather than erroring out when I get a bad control
sequence, I should just print a warning and ignore it.

Yes, now that I do that, I can make much more progress, and I get this
wonderfully long list of character codes that need to be supported.

Perhaps I ought to just collect values on this list? And tackle them one at a
time. Yup.

What can I use as my milestone? What is the first goal towards making a
useful terminal emulator? How about this. If I can fix my bug in the terminal
emulator, it's in good shape.

Let me give a first stab at that, see how it goes.

Here's how it went (with lots of redundancies cut out)

unhandled control sequence ESC[24;(Just 1,'H')
    + cup isn't implemented in the outputter? why not?
unhandled control sequence ESC[(Just 8,'C')
    + parm cursor right not implemented? Why not?

These should be simple to fix.

Well, I'm making progress maybe, but vim is still totally unusable, even
though it isn't given undefined control sequences anymore. There must be a bug
in the control sequences or something that's messing with things.

Here is a review of the known so far:

+ tabs print box
+ cursor isn't displayed
+ should blank the cell with the background color!
+ sequence: ESC[1;34m   - bold blue
    I get ls color now.
+ reverse video (I think) looks totally messed up
    The background thing may have fixed this.
+ vim totally doesn't work (not sure why)
    It looks like how it clears the screen doesn't work at all or something.
    when I press h, or j, the cursor jumps down to the bottom right of the
    screen, which is causing issues (it doesn't jump back as I expect).
    It might be nice to trace all the character sequences we get, see which
    one's vim is using that might be causing the problem.

    We weren't decrementing the arguments to the cup command. That made a big
    difference.
+ we don't redraw the cell where the cursor used to be.
    whose job is it? should screen say it has changed? should screen change
    the character attributes to account for the cursor when you call cellat
    too? That might be nice.

    To put of the decision about drawing the cursor I just added source and
    destination of cursor moves to the m_recent list.
+ clearing the screen in vim appears to only clear the first 24 columns?
    As if, perhaps I use rows when I should be using columns...

    Yup, I see the bug in the clr_eos implementation. It uses lines instead of
    columns. How to test this...

    Tested and fixed. Much better now.
+ control-e in vim... doesn't do the scroll it seems. Or rather, the scroll
    isn't displayed.
    vim outputs a literal control-e, so I guess that should be part of the
    terminfo maybe? What? That doesn't make sense. I can't do ^E normally...
    I bet the printed ^E is for when I type it.

    No the thing it does is: \e[24;1H\r\n
    That should scroll the screen down.

    Fixed.
+ enter at bottom of terminal does bad things.
    It should automaticall scroll down, right? Or shouldn't it?
    How should I know?
    
    Maybe this is fixed now.
    Yes, it appears to be so.
+ colors are crazy when reverse with fg and bg different.
    It looks like the fill color is not being set the same as the background
    color in that case, and the fg is just plain black.

    I switch green and blue. That might solve it.
    Yup. Fixed.
+ performance is annoyingly poor.
    profiling suggests showDisplay dominates.
    That should be pretty easy to fix, right? Just update that part of the
    display that has changed rather than the whole thing.

    And we also allocate tons of memory for calling nub to get the list of
    recent changes, which seems wrong to me...

    I updated the ShowDisplay function to only show part of the display...
    wait, or did I? No, I forgot. Good, that could explain why performance
    didn't improve any.

    I changed ShowDisplay to only show the part of the display which changed.
    It is noticably much faster. Good. Though scrolling is pretty bad still.
    Updating the whole display seems to be rather slow.

    Scrolling is noticably slow now, but the rest is fine.
+ profile shows == taking 90% allocation
    What's up with that?
    I feel like that shouldn't be the case.
    It's when getting the recently changed cells. Why don't I just use a set
    of positions rather than a list which I nub? Will that take up so much
    allocation?

    I switched to Data.Set. I'm running now. Performance is maybe... much
    better? Scrolling seems much faster to me now. That's a little surprising
    to me.

    Oh well, it's nice I guess. Let me check out the profile.
    Yes, that helps, but we still do a lot of allocation for the set.
    I wonder if it wouldn't be more efficient to just diff with the previous
    version of the screen. Or maybe if enough has changed, I can keep track of
    that? Or, what about this. How about I keep track of the rectangle which
    has changed. A single bounding box, like I do for the sdl display. This
    way for small changes, you can capture them fine, and same for big
    changes. The only loss is when you have two changes in different parts of
    the screen, such as going to the end of the line, or moving the cursor to
    an arbitrary position. That would be pretty bad maybe.
+ Every now and then vim prints: dch=p1%dP. I wonder if I forgot a \E in the t
  erminfo file?
    I had forgotten a comma. Should be fixed now.

- doesn't recognize the function key on my laptop as a keysym.
- bell output as square
- sequence: \e[%
    Triggered when visiting man pages. Not sure what this is supposed to do.
- there is no key repeat
- in vim, the status line sometimes get's copied too low, so it gets
  duplicated. It's showing up off the bottom of the terminal...
    This is a problem with using (lines scr) instead of (lines scr)-1 all over
    the place. I should be able to write a test case which would write to that
    part of the screen (with an insert line perhaps), and verify none of
    "recent" is outside the bounds of the screen.
- elinks caused some bad escape sequence.
    ESC followed by not [. I put tracing in to record what the next thing was
    so I can try to figure out the problem.

    From elinks list of unhandled:
    \E)     - start defining sequence G1
    \E7     - save state
    \E8     - restore state
    \E[?    - private mode thing (usually has additional chars)
    \E[2J   - erase whole display
    \E]     - operating system command? set color palette
    \E0;30; ... - longer length mode sequences
- sequence: ESC[4m      - underscore attribute
- sequence: ESC[24m     - underline off
- sequence ESC M        - reverse linefeed?
- on pacific with ctermer, the first column sometimes is blanked out. 
- arrow keys don't work.
- Want a way to specify font size so I can use same compiled program on both
  pacific and losaltos.
    Though I'm not sure I can automatically figure out the font size given the
    screen size, and using consoler we don't have a way to figure out the
    screen size yet.
- running `ps u` near bottom of screen causes an index out of bounds error.
  Also: quitting the top command.
    Looks like quitting top command does a ^[[25;1H. so I should figure out
    what that should do and make it work.
    


Mon May 16 18:02:10 EDT 2011

What do I want to do with this now?
Ideally I can make it useable. Even more ideally, for milestone whatever we're
on, it should be useable using the consoler backend, so that I can use it with
green.

Let me work toward the latter, see how things go.

Mon May 16 18:11:17 EDT 2011

It works great! Except, I forgot to compile my terminfo on pacific, and
scrolling is decidedly slow. It's kind of fun to run top in my terminal. You
can see all the refreshing.

Mon May 16 18:16:34 EDT 2011

I'm using the terminal emulator now. So let's say I'll keep using it, and fix
things as I need to. Which means I can claim it's ready, and move on to the
next part of the milestone!

Mon May 16 21:26:08 EDT 2011

Performance is still an issue. I wonder if we can evaluate performance by
looking at the steady state CPU usage of the terminal running top? fbterm is
2% cpu on losaltos. sdltermer takes 34% cpu. sdlcsr and termer are all over
the place between 25% and 50% cpu each.

I don't understand what takes so much cpu.

Sat May 21 17:47:39 EDT 2011

I now have 2 different front ends and 2 different backends for my terminal
emulator.

- haskell front end
    original front end for terminal emulator.
- c front end
    ported from haskell front end in hopes of improving performance.
- sdl back end
    ported from consoler back end in hopes of improving performance.
- consoler back end
    original back end for terminal emulator.

Remember the goal: use this with consoler to support my own windowing system.
This means the target back end will be consoler. The advantages of using
haskell seem slim to me now for the front end, so let me abandon the haskell
front end once the c front end is caught up to it (ie, tested).

I think, probably want to keep sdl backend around until I really understand
the performance issues.

One last note: my terminal emulator is basically not useable on pacific right
now because it burns through battery.

So I think the path is clear:
1. catch c front end up to haskell front end
2. dump haskell front end.
3. improve performance of c front + sdl back to acceptable.
4. improve performance of c front + consoler back to acceptable.
5. dump sdl back end.

Let me get to work.

A problem with (1) was I need a way to test if two screens are equal, because
that's how I want to implement my test cases. Test cases will be: create two
screens. Update one using outputter, update the other using manual commands,
verify they are the same.

So let me first do the grunt work: implement the eq_screen function.

1. done.

Sat May 21 18:44:51 EDT 2011

Bugs:
 + Can't type the digit 0, and some of the other digits are off.
    Fixed.
 + Sometimes we don't clear the whole screen in vim when scrolling.
    Looks like I used lines instead of cols for one of the clr functions.
    Yup. Found it. Bug is in parm_insert_line.

    Now, how do I test it?
    Fill up a line with text. Then insert a line there, and verify the whole
    line (or just a later character) is blanked.

    Fixed. And guess what. This my first bug entirely fixed from within the
    terminal emulator itself!
 + Memory leak: tail recursion not optimized away
    Fixed by switching inputter and outputter to use while loops.
    Watching top shows no memory increase over time now.
 + We segfault at the end.
    Could be related to this: we do tail recursion, and grow the stack
    unbounded. I think we do this in a couple places. Let me fix it.

    Nope. We still have the seg fault.
    Gdb suggests the problem is from getting a NUL character. Err, maybe from
    trying to display a null character?

    No. Gdb suggests the problem is trying to set cell 11, 58. Somehow the
    cursor gets wacked out. It's like maybe I swapped a row and column
    somewhere. Or maybe some application is mean... I guess I could record the
    output from the client. In fact, I already have some idea, because the
    problem occurs when I run dmesg.

    The trouble is, I can't handle bad input. Any application could craft some
    control sequences which totally break me. That's not an acceptable long
    term solution. The question is: is it the application which is messing up,
    or is it me?

    Let me put a whole bunch of assertions in, to verify I'm not asked to do
    something bad.
    
    Found it. Problem was with tabs at the end of the line, or something else
    like that. It seems to be fixed now.
 + No key repeat. It's kind of annoying.
    enabled in sdltermer.
 + Trouble with screen: It's like reverse mode gets stuck on or something.
    set default background was set to white instead of black. Fixed now.

 + doesn't end cleanly: I always see like: read error, or some other such
   assertion.
    gdb reports the problem in the call to GetEvent, deep down in X.

    What's supposed to happen?
    Well, hmm... So outputter gets a terminator character, at which point it
    knows to stop. We could also have inputter get a Quit event.

    I have a hypothesis. The issue is we have one thread stalled waiting on an
    event, and another thread which calls SDL_Quit. I bet that's bad.

    Let me propose a different way of working things.
    Let's say when the outputter thread terminates, that pushes an SDL_Quit
    event. Then it's the inputters job to wait for the Quit event?

    Um... But that doesn't fit my abstraction.

    I think the "right" thing to do is as follows: the inputter is the main
    thread. when it gets a Quit event, the program ends.

    The outputter is the child thread. When it gets the terminator character,
    it sends a Quit event. So I should maybe have a ctermer_Quit(). For
    sdlctermer it will push a quit event. The idea should be if ctermer_Quit()
    is called, anyone waiting on an input event will get a Quit event.

    That's easy to do with sdlctermer. I don't know how to do it with ctermer.

    The deal is, inputter we be stuck waiting on an event. Either we give him
    the event, or he doesn't get any event.

    The other question is if there is some pthread way to kill off inputter.
    But that's not the right solution...

    So I'll fudge it. I'll get sdltermer to work right, and have ctermer
    assert or something and deal with it later. Cool! Sounds good.

    I made the changes. sdltermer ends cleanly now according to gdb, but I do
    get this read error in ctermer_FromTermClient. Why is that?

    so inputter is waiting for an event.
    now outputter is getting from the client, and the client no longer exists,
    so that maybe gives a read error. That's when we realize we should be
    done. But why is that a read error and not end of file?

    I'm not sure. I'll just ignore it for now and claim this is fixed.

  + typing q after top gives an assertion error.
    Yes. top is outputting a cursor_address call to 26, which is line 25.
    
    On the linux console that is approximated as going to the last line. I
    don't know what it should do. Simplest would be to the nearest in bounds
    location. If it's undefined it doesn't matter what I do right?

    I just do that now.
        
Sat May 21 21:14:31 EDT 2011

I know have all known bugs worked out for sdltermer. And while I expect it
will probably not work very well with elinks, I bet it is totally usable at
this point. I should start using it instead of fbterm.

Sat May 21 21:17:31 EDT 2011

Didn't take long to find some issues.
 + arrow keys don't work. Like, readline history.
    I'm inputting the wrong strings: \eA, \eB instead of \e[A \e[B
 + unicode: character 0x2018 (a fancy quote) comes out as a box.
    This showed up when calling gcc and there was an error:
        a.c|8| error: ‘stderr’ unde
    This will require a bit of a change. Characters in the screen will have to
    switch to wide characters or something, and I need a way to put wide
    characters, and then I need outputter to recognize unicode and convert to
    wide characters. It won't be too bad. I should use the same format of
    character as freetype, don't you think?

    Okay, here's how it works. unicode is a 31 bit character set. utf-8 is an
    encoding of unicode. All I need to do is convert the utf-8 encoding into a
    32 bit word and pass that to freetype. So my characters should have a
    different type: maybe int. Or unsigned int. I wonder if there already
    exists a special type for them, such as wchar. Oh, looks like: wchar_t
    maybe? Yes, let me use that. So this change should be easy to make now.

    Works now!

 - doesn't support ctrl-alt-Fx switching between sdltermer and X.
    It just freezes up.
    I switched to ignoring unhandled input keys instead of asserting. I think
    that will fix this.
 - control-g in vim seems to have some issues.
 - I'm having issues with readline. Maybe bell related?
    I disabled the bell. Let's see if that fixes things.
 - For useability, I need a version of sdltermer which doesn't read bench.

    
I would say (2) and (3) are done now. Which basically says the next step is
improving the performance of sdlcsr. Because let's face it, it's bad.

