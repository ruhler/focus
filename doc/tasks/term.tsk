
Mon Apr  4 17:11:18 EDT 2011

Task: Implement a terminal emulator using this framework.

I checked out freetype, and it looks like it has all need to draw characters
from a truetype (and many other) fonts, so I shouldn't need SDL to implement
the terminal.

It will be like fbterm, but I think this time around I should do things a
little differently. Rather than manipulating the displayed image for things
like character erasing and scrolling, I should keep in memory the characters
currently displayed to the screen, and draw those on demand.

Perhaps we can use a circular buffer to make scrolling easier.

Maybe this will help with performance. Maybe not. But one thing it certainly
does is separate the terminal control and content code from the graphics code.

The first big question is: what should I call the terminal?

Mon Apr  4 18:47:44 EDT 2011

I have a name proposal: termer
It's pretty lame, but simple.

For now I can include the source with the rest of the focus project.
(Let's say the focus project includes the consoler library and a number of
sample applications). Eventually there's no reason for it to be bundled with
the other consoler programs.

Cool. Let me take this opportunity to refactor what fbterm was if I can. What
should the design look like?

Components:

Input Keys -> Actions
    Where this is mostly just copy it to the client, but sometimes copy more
    complex stuff, such as for arrow keys, and handle CTRL and SHIFT modifiers
    and such.

    This is called vti in fbterm.

Output Chars -> Actions
    Interpret output from the client.
    This is often: draw a character and move the cursor.
    Sometimes it is interpreting sequences.

    This is called vto in fbterm.

Action -> ConsoleState
    We keep console state: what characters are on the screen, their colors,
    current color, cursor position.

    This is affected by commands from the Output Chars.

    This is called sdlt in fbterm.

    But in fbterm it dealt with both display and console state. The state
    (characters at least) was stored as part of the raster image of the
    screen.

    Here I imagine we'll just use a 2D array (maybe circular buffer) to hold
    all the character contents (and their characteristics: color, style, etc).

    The actions will update those appropriatly. There need not be any notion
    of how to draw the characters on the screen. So in theory if I wanted to
    this same module could be reused by fbterm and termer.

ConsoleState -> Display
    Some way to draw a display. Perhaps we provide callback functions to
    ConsoleState module to call when display is performed? Hmm...
    
All that remains in fbterm is this configuration module (which uses tcl), and
the main program which glues things together.

I don't know what the best way to do this is. But maybe I can think of it in a
hardwarish kind of way. Let's say the inputer takes a stream of key presses
as inputs and outputs a stream of Actions (which are maybe just character
strings?) to send to the client.

Then say the output takes a stream of key presses and converts it to a stream
of actions.

Then say the ConsoleState takes a stream of input actions and ... has some way
to query it's state. Maybe someway to ask what's changed since the last query?
That might be nice.

Then say the displayer has a pointer to the console state, whenever asked it
can update the display. Perhaps one of the input actions can be "IDLE"?

And these all can communicate through FIFOs? That seems a little strange to
me, I must admit. Ug. I'll keep thinking about it.

I wonder if I can think about it in terms of a transaction based shared memory
model like in fiddler?

Sat Apr  9 12:17:45 EDT 2011

Let me start one piece at a time.  Starting with the input module.

Input is: a sequence of key presses and key releases. Because I guess I'll
handle key modifiers manually too (is shift down? etc...).

Output is: well, eventually a sequence of bytes sent to the terminal
application. So maybe we can think of it as just a file.

From the modules point of view it should, I think, be running in its own
thread. It should explicitly perform gets to get an input, and it should
explicitly perform puts to output an output.

So maybe we instantiate it with callback functions: get and put. The get
function will return the next key press or release (so, event). The put
function will take a string of bytes, perhaps with explicit length.

Sat Apr 30 09:51:40 EDT 2011

I've thought about things, and decided yes, even though it will get painful, I
should implement the terminal emulator in haskell. Understand what the pain
is. Because I understand the pain of C, and I know haskell fixes much of that
pain. I don't understand the pain of haskell. Maybe if I did I could figure
out how to fix it.

In haskell things look like this:
- inputter:  process which gets events, puts characters
- outputter: process which gets (UTF8) characters, updates shared character
  array.
- displayer: process which draws shared character array to the screen
  Ideally this gets lower priority than the outputter. Is that possible?

And is that it? Those are the only processes I need? Maybe a main program to
set things going, and certainly libraries to access the underlying consoler
protocol, but that seems fairly nice to me.

First step is inputter. I should be able to implement and test it purely.

Steps to implement
 + define event type
 - implement inputter module
 - test inputter module

Easy, no? Let me dive into a rough draft.

Sat Apr 30 09:58:44 EDT 2011

I defined the event type. That was trivial.
Now for the inputter module.

Oh my god. The inputter doesn't even have to know about STM haskell! It can be
made to work with a general monad, which should make testing it trivial!
Wonderful!

Except, I need to have some way of stopping the inputter. Perhaps it can
listen for a Quit event of some sort? That would make testing much easier. It
could be useful temporarally.

Sat Apr 30 11:37:10 EDT 2011

I've written the rough draft of the inputter. It's a little verbose, but not
terrible. I fear for performance (that we do hundreds of comparisons when we
could just do a single addition to translate keysym to input char), but I'm
putting that out of my mind until it is really shown to be a problem.

Now what I need is to write some tests.
I guess I can start with a really simple test: verify KEYSYM_A sends 'a'.
I can add more tests if I want to, or just one, then add more when things fail
to work. Whatever. Minimum is one test though. Set up the hunit stuff, get it
all to compile.

Sat Apr 30 12:34:03 EDT 2011

My three tests pass! First try. Nifty.

So, what's next?

Next is the outputter module.
The task of the outputter module is to interpret a stream of characters into
actions which modify the terminal state. Basically actions are:
change the cursor, change characters and attributes of the character buffer.

So, before doing the translation, I really want an abstract data type
representing the console state.

It should include the following:

- Number of lines
- Number of columns
- The current cursor position (line and column)
- The current fgcolor, bgcolor, style
- For each position: character, style, fgcolor, bgcolor
    color is one of: black, red, green, yellow, blue, magenta, cyan, white
    style is one of: reverse, bold

Methods on the terminal might be:
 - clear
 - insert line
 - clear to end of line
 - scroll forward
 - set foreground
 - set background
 - set reverse
 - set bold

Do you think? What about
 - cursorup, cursordown, etc...
 - some way to get at the contents of cells.
    So I think the CELLS should be public, but representation of the terminal
    (be it array, tree, list, whatever) should be private.

Cool. That's fairly clear. Or rather, the direction is clear, the detail has
to be worked out. Shall I do that on the fly?

Sure, why not? But what do I call this module? Terminal? Display? Screen?
Output?

You know? I like Screen. We can save Display for displaying the screen. Here I
go then. Wish me luck.

Sat Apr 30 14:54:35 EDT 2011

I completed a rough draft of Screen. I think it has everything we'll need for
fbterm equivalent functionality. The details are not at all documented (or
decided on) yet, which I should probably do...

I would say the next step is to write some tests for the Screen module. But
before I test a function, take the time to work out the specific details for
that function which makes sense to have and document it.

Cool. Sounds like a plan.

Sun May  1 11:31:26 EDT 2011

I've gone through the terminfo capabilities. I think it would be great of the
screen functions were named after these capabilities. That way it's clear
based on terminfo documentation what the thing should do, and I don't have to
come up with my own names.

Cool. So then, initial capabilities I should do are:

+ carriage_return
+ column_address
+ cursor_address
+ cursor_down
+ cursor_home
+ cursor_left
+ cursor_right
+ cursor_to_ll
+ cursor_up
+ parm_left_cursor
+ parm_right_cursor
+ parm_up_cursor
+ parm_down_cursor
+ row_address
+ newline
+ tab

+ clear_screen
+ clr_bol
+ clr_eol
+ clr_eos

+ enter_bold_mode
+ enter_reverse_mode
+ exit_attribute_mode

+ set_background
+ set_foreground

+ delete_character
+ parm_dch
+ delete_line
+ parm_delete_line
+ erase_chars

+ insert_character
+ parm_ich
+ insert_line
+ parm_insert_line

+ scroll_forward
+ parm_index
+ scroll_reverse
+ parm_rindex

For the fun of things, maybe I can say I'll implement all of these as Screen
functions, test them all, then I'll be in great shape to go on to implement
the rest of the terminal emulator.

Cool. Am I ready?
Allow me to spend 20 minutes on this, see how far I get.

Sun May  1 13:34:20 EDT 2011

So I took a bit more than 20 minutes to do this. Fine. But now I have all the
big ones implemented. I suspect almost all of them have bugs in them, so I
should get a nice test suite going. That's the plan now. I'll write tests for
each function, try to get them all working. Can I do it in 25 minutes you
think? We'll see.

Sun May  1 15:20:01 EDT 2011

So I write some tests. Mostly for the cursor motions. The reason I don't feel
like writing more right now is it is hard to write tests that check multiple
cells on the screen in the same test. So I'll wait until I actually run into
bugs, or get bored enough to write the tests, before writing more tests.

That said, what's the next step? Assuming inputter works swell, and assuming
screen works well, the next step should be outputter, right?

The job of outputter is to convert a sequence of characters from the client
into a sequence of Screen commands. It would be awesome if I could test this
without Screen, don't you think?

Or maybe I need to come up with a good way of describing a screen for test
purposes. Then I could give a long string, do the conversion and update the
screen, then test the final screen is correct.

I suppose I could send a string, generate an output screen.
And then on a different screen send all the expected commands.
Then compare to see whether the resulting screens are the same.

That's not so bad an idea.

What's the outputter interface? It should be its own process. It gets two
functions I think:
  getf :: m Char, get the next input character
  update :: Screen -> Screen -> m (),
    Make a change to the screen.

  For testing, the update function looks a lot like modify on a State Screen
  monad.

Good, I like this idea for testing the outputter.

I don't really feel like working on the output just at this moment (must be
time to take a walk or something). Let's imagine I've already implemented
outputter. Then what would be the next step? After outputter is displayer.
That's where things will get tricky, because I'll want to incorporate the CNSL
stuff into haskell, and freetype library. Basically the display turns a Screen
into a CNSL buffer. After that things get tricky again, because I have to
start worrying about concurrency, getting and setting CNSL events and
displays, launching the client and so on.

So it only gets harder, and much harder. Or rather, much more annoying.

Tue May  3 09:20:10 EDT 2011

Outputter! I could try using parsec, but I feel like that is overkill for this
simple parsing. Basically all we need to parse are character literals and
integers. So if I can have a function to extract the next character literal
(which will be called getf, we already have it), and a function to extract the
next integer, we should be in good shape.

I'll probably want to buffer a single character.

And I'll need to decide on the terminfo. Perhaps it would be better to write
the terminfo file first, so I know what all sequences I need to parse. Yes,
that would make sense. I want to stay ansi or vt102 or common compatable
rather than make up something wildly different.

So let me do that now, I think I can do that.

Tue May  3 09:52:36 EDT 2011

I did that. What do we see? It's as I expected, we only need to parse literal
characters and decimal integers.

Rather than require a buffer, I suggest we have the following functions:
 getf :: m Char     - get the next character literal
 getnum :: Char -> m (Maybe Integer, Char)
        - read the integer at the front of the string and the following char.
          If there is no integer at the front of the string, return Nothing
          for that field.

 In fact, I could use the getnum function always if I wanted to...

Yes, that looks like it will be a straight-forward, relatively painless way of
parsing the control sequences.


