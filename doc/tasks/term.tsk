
Mon Apr  4 17:11:18 EDT 2011

Task: Implement a terminal emulator using this framework.

I checked out freetype, and it looks like it has all need to draw characters
from a truetype (and many other) fonts, so I shouldn't need SDL to implement
the terminal.

It will be like fbterm, but I think this time around I should do things a
little differently. Rather than manipulating the displayed image for things
like character erasing and scrolling, I should keep in memory the characters
currently displayed to the screen, and draw those on demand.

Perhaps we can use a circular buffer to make scrolling easier.

Maybe this will help with performance. Maybe not. But one thing it certainly
does is separate the terminal control and content code from the graphics code.

The first big question is: what should I call the terminal?

Mon Apr  4 18:47:44 EDT 2011

I have a name proposal: termer
It's pretty lame, but simple.

For now I can include the source with the rest of the focus project.
(Let's say the focus project includes the consoler library and a number of
sample applications). Eventually there's no reason for it to be bundled with
the other consoler programs.

Cool. Let me take this opportunity to refactor what fbterm was if I can. What
should the design look like?

Components:

Input Keys -> Actions
    Where this is mostly just copy it to the client, but sometimes copy more
    complex stuff, such as for arrow keys, and handle CTRL and SHIFT modifiers
    and such.

    This is called vti in fbterm.

Output Chars -> Actions
    Interpret output from the client.
    This is often: draw a character and move the cursor.
    Sometimes it is interpreting sequences.

    This is called vto in fbterm.

Action -> ConsoleState
    We keep console state: what characters are on the screen, their colors,
    current color, cursor position.

    This is affected by commands from the Output Chars.

    This is called sdlt in fbterm.

    But in fbterm it dealt with both display and console state. The state
    (characters at least) was stored as part of the raster image of the
    screen.

    Here I imagine we'll just use a 2D array (maybe circular buffer) to hold
    all the character contents (and their characteristics: color, style, etc).

    The actions will update those appropriatly. There need not be any notion
    of how to draw the characters on the screen. So in theory if I wanted to
    this same module could be reused by fbterm and termer.

ConsoleState -> Display
    Some way to draw a display. Perhaps we provide callback functions to
    ConsoleState module to call when display is performed? Hmm...
    
All that remains in fbterm is this configuration module (which uses tcl), and
the main program which glues things together.

I don't know what the best way to do this is. But maybe I can think of it in a
hardwarish kind of way. Let's say the inputer takes a stream of key presses
as inputs and outputs a stream of Actions (which are maybe just character
strings?) to send to the client.

Then say the output takes a stream of key presses and converts it to a stream
of actions.

Then say the ConsoleState takes a stream of input actions and ... has some way
to query it's state. Maybe someway to ask what's changed since the last query?
That might be nice.

Then say the displayer has a pointer to the console state, whenever asked it
can update the display. Perhaps one of the input actions can be "IDLE"?

And these all can communicate through FIFOs? That seems a little strange to
me, I must admit. Ug. I'll keep thinking about it.

I wonder if I can think about it in terms of a transaction based shared memory
model like in fiddler?

Sat Apr  9 12:17:45 EDT 2011

Let me start one piece at a time.  Starting with the input module.

Input is: a sequence of key presses and key releases. Because I guess I'll
handle key modifiers manually too (is shift down? etc...).

Output is: well, eventually a sequence of bytes sent to the terminal
application. So maybe we can think of it as just a file.

From the modules point of view it should, I think, be running in its own
thread. It should explicitly perform gets to get an input, and it should
explicitly perform puts to output an output.

So maybe we instantiate it with callback functions: get and put. The get
function will return the next key press or release (so, event). The put
function will take a string of bytes, perhaps with explicit length.

Sat Apr 30 09:51:40 EDT 2011

I've thought about things, and decided yes, even though it will get painful, I
should implement the terminal emulator in haskell. Understand what the pain
is. Because I understand the pain of C, and I know haskell fixes much of that
pain. I don't understand the pain of haskell. Maybe if I did I could figure
out how to fix it.

In haskell things look like this:
- inputter:  process which gets events, puts characters
- outputter: process which gets (UTF8) characters, updates shared character
  array.
- displayer: process which draws shared character array to the screen
  Ideally this gets lower priority than the outputter. Is that possible?

And is that it? Those are the only processes I need? Maybe a main program to
set things going, and certainly libraries to access the underlying consoler
protocol, but that seems fairly nice to me.

First step is inputter. I should be able to implement and test it purely.

Steps to implement
 + define event type
 - implement inputter module
 - test inputter module

Easy, no? Let me dive into a rough draft.

Sat Apr 30 09:58:44 EDT 2011

I defined the event type. That was trivial.
Now for the inputter module.

Oh my god. The inputter doesn't even have to know about STM haskell! It can be
made to work with a general monad, which should make testing it trivial!
Wonderful!

Except, I need to have some way of stopping the inputter. Perhaps it can
listen for a Quit event of some sort? That would make testing much easier. It
could be useful temporarally.

Sat Apr 30 11:37:10 EDT 2011

I've written the rough draft of the inputter. It's a little verbose, but not
terrible. I fear for performance (that we do hundreds of comparisons when we
could just do a single addition to translate keysym to input char), but I'm
putting that out of my mind until it is really shown to be a problem.

Now what I need is to write some tests.
I guess I can start with a really simple test: verify KEYSYM_A sends 'a'.
I can add more tests if I want to, or just one, then add more when things fail
to work. Whatever. Minimum is one test though. Set up the hunit stuff, get it
all to compile.

Sat Apr 30 12:34:03 EDT 2011

My three tests pass! First try. Nifty.

So, what's next?

Next is the outputter module.
The task of the outputter module is to interpret a stream of characters into
actions which modify the terminal state. Basically actions are:
change the cursor, change characters and attributes of the character buffer.

So, before doing the translation, I really want an abstract data type
representing the console state.

It should include the following:

- Number of lines
- Number of columns
- The current cursor position (line and column)
- The current fgcolor, bgcolor, style
- For each position: character, style, fgcolor, bgcolor
    color is one of: black, red, green, yellow, blue, magenta, cyan, white
    style is one of: reverse, bold

Methods on the terminal might be:
 - clear
 - insert line
 - clear to end of line
 - scroll forward
 - set foreground
 - set background
 - set reverse
 - set bold

Do you think? What about
 - cursorup, cursordown, etc...
 - some way to get at the contents of cells.
    So I think the CELLS should be public, but representation of the terminal
    (be it array, tree, list, whatever) should be private.

Cool. That's fairly clear. Or rather, the direction is clear, the detail has
to be worked out. Shall I do that on the fly?

Sure, why not? But what do I call this module? Terminal? Display? Screen?
Output?

You know? I like Screen. We can save Display for displaying the screen. Here I
go then. Wish me luck.

Sat Apr 30 14:54:35 EDT 2011

I completed a rough draft of Screen. I think it has everything we'll need for
fbterm equivalent functionality. The details are not at all documented (or
decided on) yet, which I should probably do...

I would say the next step is to write some tests for the Screen module. But
before I test a function, take the time to work out the specific details for
that function which makes sense to have and document it.

Cool. Sounds like a plan.

Sun May  1 11:31:26 EDT 2011

I've gone through the terminfo capabilities. I think it would be great of the
screen functions were named after these capabilities. That way it's clear
based on terminfo documentation what the thing should do, and I don't have to
come up with my own names.

Cool. So then, initial capabilities I should do are:

+ carriage_return
+ column_address
+ cursor_address
+ cursor_down
+ cursor_home
+ cursor_left
+ cursor_right
+ cursor_to_ll
+ cursor_up
+ parm_left_cursor
+ parm_right_cursor
+ parm_up_cursor
+ parm_down_cursor
+ row_address
+ newline
+ tab

+ clear_screen
+ clr_bol
+ clr_eol
+ clr_eos

+ enter_bold_mode
+ enter_reverse_mode
+ exit_attribute_mode

+ set_background
+ set_foreground

+ delete_character
+ parm_dch
+ delete_line
+ parm_delete_line
+ erase_chars

+ insert_character
+ parm_ich
+ insert_line
+ parm_insert_line

+ scroll_forward
+ parm_index
+ scroll_reverse
+ parm_rindex

For the fun of things, maybe I can say I'll implement all of these as Screen
functions, test them all, then I'll be in great shape to go on to implement
the rest of the terminal emulator.

Cool. Am I ready?
Allow me to spend 20 minutes on this, see how far I get.

Sun May  1 13:34:20 EDT 2011

So I took a bit more than 20 minutes to do this. Fine. But now I have all the
big ones implemented. I suspect almost all of them have bugs in them, so I
should get a nice test suite going. That's the plan now. I'll write tests for
each function, try to get them all working. Can I do it in 25 minutes you
think? We'll see.

Sun May  1 15:20:01 EDT 2011

So I write some tests. Mostly for the cursor motions. The reason I don't feel
like writing more right now is it is hard to write tests that check multiple
cells on the screen in the same test. So I'll wait until I actually run into
bugs, or get bored enough to write the tests, before writing more tests.

That said, what's the next step? Assuming inputter works swell, and assuming
screen works well, the next step should be outputter, right?

The job of outputter is to convert a sequence of characters from the client
into a sequence of Screen commands. It would be awesome if I could test this
without Screen, don't you think?

Or maybe I need to come up with a good way of describing a screen for test
purposes. Then I could give a long string, do the conversion and update the
screen, then test the final screen is correct.

I suppose I could send a string, generate an output screen.
And then on a different screen send all the expected commands.
Then compare to see whether the resulting screens are the same.

That's not so bad an idea.

What's the outputter interface? It should be its own process. It gets two
functions I think:
  getf :: m Char, get the next input character
  update :: Screen -> Screen -> m (),
    Make a change to the screen.

  For testing, the update function looks a lot like modify on a State Screen
  monad.

Good, I like this idea for testing the outputter.

I don't really feel like working on the output just at this moment (must be
time to take a walk or something). Let's imagine I've already implemented
outputter. Then what would be the next step? After outputter is displayer.
That's where things will get tricky, because I'll want to incorporate the CNSL
stuff into haskell, and freetype library. Basically the display turns a Screen
into a CNSL buffer. After that things get tricky again, because I have to
start worrying about concurrency, getting and setting CNSL events and
displays, launching the client and so on.

So it only gets harder, and much harder. Or rather, much more annoying.

Tue May  3 09:20:10 EDT 2011

Outputter! I could try using parsec, but I feel like that is overkill for this
simple parsing. Basically all we need to parse are character literals and
integers. So if I can have a function to extract the next character literal
(which will be called getf, we already have it), and a function to extract the
next integer, we should be in good shape.

I'll probably want to buffer a single character.

And I'll need to decide on the terminfo. Perhaps it would be better to write
the terminfo file first, so I know what all sequences I need to parse. Yes,
that would make sense. I want to stay ansi or vt102 or common compatable
rather than make up something wildly different.

So let me do that now, I think I can do that.

Tue May  3 09:52:36 EDT 2011

I did that. What do we see? It's as I expected, we only need to parse literal
characters and decimal integers.

Rather than require a buffer, I suggest we have the following functions:
 getf :: m Char     - get the next character literal
 getnum :: Char -> m (Maybe Integer, Char)
        - read the integer at the front of the string and the following char.
          If there is no integer at the front of the string, return Nothing
          for that field.

 In fact, I could use the getnum function always if I wanted to...

Yes, that looks like it will be a straight-forward, relatively painless way of
parsing the control sequences.

Fri May  6 21:30:06 EDT 2011


I figured out how to use freetype to draw characters on the screen. For the
most part anyway. It's not too bad.

Now that outputter is up and running, we've reached the hard part: hooking up
CNSL to haskell.

Tasks involved:
 - haskell function to get next input event
 - haskell function to fork a terminal client
 - haskell function to write a character to the terminal client
 - haskell function to read a character from the terminal client
 - haskell function to draw a character with given color

And generally just understanding how all this will work. That is, defining the
interface.

Options:
 - keep as much CNSL stuff on the C side as possible
   - so only get CNSL_Events, and draw characters. Drawn characters can be
     immediately updated and displayed, or have a function to send display,
     where the display is implicit. When drawing characters we can specify
     location in terms of row and col rather than in pixels.

 - try to make haskell interface for CNSL completely general
  - have a way to allocate a buffer.
  - have a way to render a character to a buffer at the given location.
  - have a way to send that buffer to the server. etc...
    
That's something I'll have to think about for the next step.

Sat May  7 18:02:23 EDT 2011

Here's the plan next. I have this interface between haskell and C to implement
which looks something like:

init - initialize stuff. Maybe even takes the terminal client application and forks it.
getevent - get the next event
    I may want to split this up into: next, type, and value methods to make the conversion easier.
putchar - pass a character to the terminal client.
    Or would it be easier to just return a write file handle? Perhaps.
getchar - get a character from the terminal client
    Would probably be easier to return a read file handle (from init) and use that.
drawchar - draw a character (using freetype) on the display (implicit).
    input is: character, foreground color, background color, row, col
upddisplay - send the display (with characters drawn on it) to the console server.

Implement the C and haskell sides of the interface. That's the next step.

After that, just write some haskell to use the interface. Basically it's: initialize, then fork threads (don't even need SMT, just CC will be enough) to do
    inputter: get is getevent, put is putchar
    outputter: get is getchar, updatef is update screen, drawchars and update display
    
And it should be that simple. Cool. I'll work that tomorrow.

Sun May  8 10:40:17 EDT 2011

Working out the haskell/C interface is more detail now.

First, some questions to answer:
 - Is is possible to send structure across haskell FFI? How?
    If so, we should just have a getevent function, if not we should have
    next, type, and value methods for sending an event from C to haskell.

    It looks like it is possible using Storable, but it also looks like it's a
    pain. Much easier for now to just make multiple function calls to get the
    data.

 - Is is possible to send enums across haskell FFI? How?
    If so, that would be useful in sending color info from haskell to C
    Otherwise just pack it to an int.

    Doesn't look like it. Just convert to an Int and unconvert.

 - Is there a way to do an fdopen in haskell?
     If yse, then putchar and getchar can be replaced with files, and we should
     automatically get character support.

     It looks like it's possibly possible, if I hack into some ghc specific low
     level stuff, but probably unpleasent.

 - How is unicode character translation done across haskell FFI?
     It would be nice. For putchar and getchar if I need those, and for
     drawchar to specify the character.

    There is a way to send strings, which seems to handle unicode. There are
    also functions to convert Char to CChar which just drop unicode characters.


So, the conclusion? It's pretty sad. I'm going to loose unicode I suspect. I'll
have to fix that later. It should be okay for the first version of term.

So the interface is as before. I'll want a prefix. Maybe CTERM? Sure... For
the C side of Termer.

int CTERM_Init()
  Initialize the cterm. It does
    - initialize CNSL,
    - initialize freetype
    - fork a client process: for now always just fork /bin/bash or some such.
    - allocate a CNSL_Display

void CTERM_EventGet()
    - Get the next event. Stores the event in a static place accessible with  
      CTERM_EventType and CTERM_EventValue

CInt CTERM_EventType()
    - Return the type of the most recently gotten event.
      Do not call before EventGet is called, as you'll get undefined results.

CInt CTERM_EventValue()
    - Return the value of the most recently gotten event.

void CTERM_ToTermClient(CChar c)
    - Send the character c to the terminal client.

CChar CTERM_FromTermClient()
    - Get a character from the terminal client.

void CTERM_DrawCell(CChar c, CInt style, CInt fgcolor, CInt bgcolor, CInt col, CInt row);
    c - the character of the cell
    style - bold or not
    fgcolor - foreground color enum
    bgcolor - background color enum
    col - column of cell to draw
    row - row of cell to draw

    Draw a cell using freetype to the right place in the display.

void CTERM_ShowDisplay()
    Send the current display to the consol server.


I think this will be a good first start. And I have clear what I need to
write.  The task now is to implement the c cide of this, let's say in
ctermer.h and ctermer.c.

Sun May  8 13:21:25 EDT 2011

I wrote the rough draft of ctermer.h and ctermer.c. No issues. It seems rather
straight forward. Next step? I might as well get it compiling before I move on
to the haskell side of the interface. Should I make a library? Or just a .o
file? I'll have to look at other projects I've done with ffi.

It looks like I just pass the c file to GHCProgram, so I'll wait until I have
the haskell side up to try compiling.

Next steps:
1. The haskell side: CTermer.hs.
2. Use CTermer.

I expect this is actually a very little amount of code, which shouldn't take
an hour to write up and get compiling.

What are the problems I anticipate?
 - How do we know the dimensions of a character cell?
 - I don't have the font I use installed, so that's bad.
 - Maybe need to install concurrent haskell package?
 - There's bound to be deadlock when I run it, and it will likely crash my
   machine if I'm not running in X. So I should probably debug this in X
   (maybe go to the athena lab once it compiles on my netbook).
 - What does the end game look like? How do I stop the terminal emulator?

So, time for lunch, then I'll finish writing this sucker.

Sun May  8 14:24:54 EDT 2011

I wrote CTermer.hs. Now all that's left is the main application, right?
I think I can do this. Call it Termer.hs. Inputter and outputter is all I
need, yes?

Sun May  8 14:40:56 EDT 2011

There, rough draft is all written. In theory I can end the application by
typing Ctrl-E. Time to try compiling and seeing what all the problems are.

Sun May  8 14:59:55 EDT 2011

It compiles!
Now, obviously it won't work if I run it. I'll have to reboot my computer and
all. So let me commit and push now, then try to get it working on my netbook.
Once it crashes things, switch to an athena cluster, get everything up to
date, then try to get things working there.

Sun May  8 16:12:52 EDT 2011

This font thing is annoying. What's the right way to specify the font to use?

Anyway, after the font issue we run into this bug: y is out of range in our
call to SetPixel in DrawCell. The issue: CHAR_HEIGHT isn't right. How do I
make it right?

I made that bigger and guess what! It sort of works! Very slowly, fine, but I
see characters going by, but then they overwrite eachother and I see lots of
funny squares and all that.

So, let's see how I can make progress...

It says: execl: no such file or directory I think.
Ah yes, I had a typo. Trying again...

Problem now: unhandled control sequence: ESC[1;
So switching to sh...

Problem now: I only see the top half of the first row. Why is that (do we
ignore row?). And return outputs some square on the display instead of going
to the next line.

If I keep typing, it eventually wraps around. The characters are not being
drawn in their entirety, and they certainly aren't being drawn in a consistent
part of the cell.

So I think the next steps are:
 - really understand how I can know the cell character dimensions based on the
   font size, and where in the bitmap the characters are getting drawn.
 - I think we have the following bug which should be easy to test: when you
   reach the end of the last line, it should automatically scroll the
   terminal.
 - We don't end properly: I think application outputs a bunch of EOF
   characters or NULs. I should use that as trigger for when to quit.

I would much prefer to get the font stuff working first so I can see better
what's going on. That's the key next step.

But I must say, this is really cool. It's going to work!

Okay, let's figure out the font thing.

Current thoughts:

We specify pixel size width and height. It looks terrible unless I set width
and height as the same: like 32x32, but I know the cell sizes shouldn't be
square.

My belief is freetype produces a bitmap which only contains lines and columns
with pixels in them. That is, it won't include black space around the edge. To
make up for that, it tells you where the bitmap should be placed with respect
to some known point on the character using bitmap_left and bitmap_top.
Specifically, bitmap_left is the number of pixels to the right of the origin
of the CELL where the bitmaps first column should be placed. And bitmap_top is
the number of pixels number of pixels above the CELL where the bitmaps top row
should be placed?

What I would like to know is: from freetype, what is the bounding box for the
CELL? What are the dimensions?

Now to read some documentation.

Read about FT_Set_Pixel_Sizes

bitmap_left: horizontal distance from the current pen position to the leftmost
border of the glyph bitmap. If pen is cell, that sounds right.

bitmap_top: vertical distance from the pen position to the topmost border of
the glyph bitmap. Oh. That's a little different right? No. That's what I
thought too.

Aha! Here's an important point I may have missed. The y direction for display
buffer is 0 at the top, and increases going down.

So given I want to draw a character at cell (0, 0), whose x and y coordinates
are 0 and 0, I want to draw the bitmap's upper left corner at x = bitmap_left
and y = height - bitmap_top, right? Isn't that what I do?

Oh, here's something: slot->advance.x and slot->advance.y may contain the
width and height of the cell (but 64 times that really).

face->glyph->metrics.width: bounding box of a glyph
                    .height

These seem to be character specific. I'm more interested in characters in
general (but maybe that only makes sense for monospace?).

Read about FT_Set_Pixel_Sizes
Read about FT_Size_Metrics
Read about FT_Glyph_Get_CBox

Aha, making progress now...
Fields of the face:
    units_per_EM
    bbox - aha! This is good
    height

Even better:
    face->size->metrics.height

Oh, so Set_Pixel_Sizes just relates pixels to EM, where EM is like the font
metrics: 1000 for example.

I think I should do an experiment.
Print out the following things:

advance.x, advance.y, face->size->metrics.height
units_per_EM, bbox, height. Let's use a 32 bit pixel size.

Sun May  8 17:27:40 EDT 2011

Oh, I found  a bug. I was using w instead of h. Now characters are lined up, I
can see them all. Not sure about the size it's supposed to be from the
metrics, but it looks good.

Good enough, indeed to start making progress. Let me just figure out how to
exit it cleanly so I can work on it on my netbook. And I think I'm in shape
now to start making great progress!

Sun May  8 21:12:20 EDT 2011

Suspected bugs to test and fix:
 - Doesn't autoscroll at bottom of terminal.
 - backspace doesn't move the cursor backwards.
 - newline character (and enter) not treated as newline.
 - characters overstrike instead of replacing what's there.

All of these should be pretty easy to test and fix, except the last is a
little tricker to test. Let's go one at a time.

Autoscroll: add as Screen test.

