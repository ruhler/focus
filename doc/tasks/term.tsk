
Mon Apr  4 17:11:18 EDT 2011

Task: Implement a terminal emulator using this framework.

I checked out freetype, and it looks like it has all need to draw characters
from a truetype (and many other) fonts, so I shouldn't need SDL to implement
the terminal.

It will be like fbterm, but I think this time around I should do things a
little differently. Rather than manipulating the displayed image for things
like character erasing and scrolling, I should keep in memory the characters
currently displayed to the screen, and draw those on demand.

Perhaps we can use a circular buffer to make scrolling easier.

Maybe this will help with performance. Maybe not. But one thing it certainly
does is separate the terminal control and content code from the graphics code.

The first big question is: what should I call the terminal?

Mon Apr  4 18:47:44 EDT 2011

I have a name proposal: termer
It's pretty lame, but simple.

For now I can include the source with the rest of the focus project.
(Let's say the focus project includes the consoler library and a number of
sample applications). Eventually there's no reason for it to be bundled with
the other consoler programs.

Cool. Let me take this opportunity to refactor what fbterm was if I can. What
should the design look like?

Components:

Input Keys -> Actions
    Where this is mostly just copy it to the client, but sometimes copy more
    complex stuff, such as for arrow keys, and handle CTRL and SHIFT modifiers
    and such.

    This is called vti in fbterm.

Output Chars -> Actions
    Interpret output from the client.
    This is often: draw a character and move the cursor.
    Sometimes it is interpreting sequences.

    This is called vto in fbterm.

Action -> ConsoleState
    We keep console state: what characters are on the screen, their colors,
    current color, cursor position.

    This is affected by commands from the Output Chars.

    This is called sdlt in fbterm.

    But in fbterm it dealt with both display and console state. The state
    (characters at least) was stored as part of the raster image of the
    screen.

    Here I imagine we'll just use a 2D array (maybe circular buffer) to hold
    all the character contents (and their characteristics: color, style, etc).

    The actions will update those appropriatly. There need not be any notion
    of how to draw the characters on the screen. So in theory if I wanted to
    this same module could be reused by fbterm and termer.

ConsoleState -> Display
    Some way to draw a display. Perhaps we provide callback functions to
    ConsoleState module to call when display is performed? Hmm...
    
All that remains in fbterm is this configuration module (which uses tcl), and
the main program which glues things together.

I don't know what the best way to do this is. But maybe I can think of it in a
hardwarish kind of way. Let's say the inputer takes a stream of key presses
as inputs and outputs a stream of Actions (which are maybe just character
strings?) to send to the client.

Then say the output takes a stream of key presses and converts it to a stream
of actions.

Then say the ConsoleState takes a stream of input actions and ... has some way
to query it's state. Maybe someway to ask what's changed since the last query?
That might be nice.

Then say the displayer has a pointer to the console state, whenever asked it
can update the display. Perhaps one of the input actions can be "IDLE"?

And these all can communicate through FIFOs? That seems a little strange to
me, I must admit. Ug. I'll keep thinking about it.

I wonder if I can think about it in terms of a transaction based shared memory
model like in fiddler?

Sat Apr  9 12:17:45 EDT 2011

Let me start one piece at a time.  Starting with the input module.

Input is: a sequence of key presses and key releases. Because I guess I'll
handle key modifiers manually too (is shift down? etc...).

Output is: well, eventually a sequence of bytes sent to the terminal
application. So maybe we can think of it as just a file.

From the modules point of view it should, I think, be running in its own
thread. It should explicitly perform gets to get an input, and it should
explicitly perform puts to output an output.

So maybe we instantiate it with callback functions: get and put. The get
function will return the next key press or release (so, event). The put
function will take a string of bytes, perhaps with explicit length.

Sat Apr 30 09:51:40 EDT 2011

I've thought about things, and decided yes, even though it will get painful, I
should implement the terminal emulator in haskell. Understand what the pain
is. Because I understand the pain of C, and I know haskell fixes much of that
pain. I don't understand the pain of haskell. Maybe if I did I could figure
out how to fix it.

In haskell things look like this:
- inputter:  process which gets events, puts characters
- outputter: process which gets (UTF8) characters, updates shared character
  array.
- displayer: process which draws shared character array to the screen
  Ideally this gets lower priority than the outputter. Is that possible?

And is that it? Those are the only processes I need? Maybe a main program to
set things going, and certainly libraries to access the underlying consoler
protocol, but that seems fairly nice to me.

First step is inputter. I should be able to implement and test it purely.

Steps to implement
 + define event type
 - implement inputter module
 - test inputter module

Easy, no? Let me dive into a rough draft.

Sat Apr 30 09:58:44 EDT 2011

I defined the event type. That was trivial.
Now for the inputter module.

Oh my god. The inputter doesn't even have to know about STM haskell! It can be
made to work with a general monad, which should make testing it trivial!
Wonderful!

Except, I need to have some way of stopping the inputter. Perhaps it can
listen for a Quit event of some sort? That would make testing much easier. It
could be useful temporarally.

Sat Apr 30 11:37:10 EDT 2011

I've written the rough draft of the inputter. It's a little verbose, but not
terrible. I fear for performance (that we do hundreds of comparisons when we
could just do a single addition to translate keysym to input char), but I'm
putting that out of my mind until it is really shown to be a problem.

Now what I need is to write some tests.
I guess I can start with a really simple test: verify KEYSYM_A sends 'a'.
I can add more tests if I want to, or just one, then add more when things fail
to work. Whatever. Minimum is one test though. Set up the hunit stuff, get it
all to compile.

